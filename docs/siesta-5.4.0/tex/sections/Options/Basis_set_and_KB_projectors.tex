
\subsubsection{Overview of atomic-orbital bases implemented in \texorpdfstring{\siesta}{SIESTA}}

The main advantage of atomic orbitals is their efficiency (fewer orbitals
needed per electron for similar precision)
and their main disadvantage is the lack of systematics for optimal
convergence, an issue that quantum chemists have been working on for
many years. They have also clearly shown that there
is no limitation on precision intrinsic to LCAO.
This section provides some information about how basis sets can be
generated for \siesta.

It is important to stress at this point that neither the \siesta\
method nor the program
are bound to the use of any particular kind of atomic orbitals. The
user can feed into \siesta\ the atomic basis set he/she choses by
means of radial tables (see \fdf{User.Basis} below), the
only limitations being: $(i)$ the functions have to be atomic-like (radial
functions mutiplied by spherical harmonics), and $(ii)$ they have to be
of finite support, i.e., each orbital becomes strictly zero beyond some
cutoff radius chosen by the user.

Most users, however, do not have their own basis sets. For these users
we have devised some schemes to generate basis sets within the program
with a minimum input from the user.  If nothing is specified in the
input file, \siesta\ generates a default basis set of a reasonable
quality that might constitute a good starting point.  Of course,
depending on the accuracy required in the particular problem, the user
has the degree of freedom to tune several parameters that can be
important for quality and efficiency. A description of these basis
sets and some performance tests can be found in the references quoted
below.

\noindent
``Numerical atomic orbitals for linear-scaling calculations'',
J. Junquera, O. Paz, D. S\'anchez-Portal, and E. Artacho, Phys. Rev. B
\textbf{64}, 235111, (2001)

An important point here is that the basis set selection is a
variational problem and, therefore, minimizing the energy with respect
to any parameters defining the basis is an ``ab initio'' way to
define them.

We have also devised a quite simple and systematic way of generating
basis sets based on specifying only one main parameter (the energy shift)
besides the basis size. It does not offer the best NAO results one can get
for a given basis size but it has the important advantages mentioned above.
More about it in:

\noindent
``Linear-scaling ab-initio calculations for large and complex systems'',
E. Artacho, D. S\'anchez-Portal, P. Ordej\'on, A. Garc\'{\i}a and
J. M. Soler, Phys. Stat. Sol. (b) \textbf{215}, 809 (1999).

In addition to \siesta\ we provide the program \program{Gen-basis}
\index{Gen-basis@\program{Gen-basis}}, which reads \siesta's input and
generates basis files for later use. \program{Gen-basis} can be found
in \texttt{Util/Gen-basis}.
It should be run from the \texttt{Tutorials/Bases} directory,
using the \texttt{gen-basis.sh} script. It is limited to a single species.

Of course, as it happens for the pseudopotential, it is the
responsibility of the user to check that the physical results obtained
are converged with respect to the basis set used before starting any
production run.

In the following we give some clues on the basics of the basis sets
that \siesta\ generates.
  The starting point is always the solution of Kohn-Sham's Hamiltonian
for the isolated pseudo-atoms, solved in a radial grid,
with the same approximations as for the solid or molecule
(the same exchange-correlation functional and  pseudopotential),
plus some way of confinement (see below).
  We describe in the following three main features of a
basis set of atomic orbitals: size, range, and radial shape.

\textbf{Size:} number of orbitals per atom

  Following the nomenclature of Quantum Chemistry, we establish
a hierarchy of basis sets, from single-$\zeta$ to multiple-$\zeta$
with polarization and diffuse orbitals, covering from quick calculations
of low quality to high precision, as high as the finest obtained in
Quantum Chemistry.
  A single-$\zeta$ (also called minimal) basis set (SZ in the following)
has one single radial function per angular momentum channel, and only for
those angular momenta with substantial electronic population in the valence of
the free atom.
  It offers quick calculations and some insight on qualitative trends
in the chemical bonding and other properties.
  It remains too rigid, however, for more quantitative calculations
requiring both radial and angular flexibilization.

  Starting by the radial flexibilization of SZ, a better basis is obtained
by adding a second function per channel: double-$\zeta$ (DZ).
  In Quantum Chemistry, the \textit{split valence} scheme
is widely used: starting from the expansion in Gaussians of one atomic
orbital, the most contracted Gaussians are used to define the first
orbital of the double-$\zeta$ and the most extended ones for the second.
  For strictly localized functions there was a first proposal
of using the excited states of the confined atoms, but it would work only
for tight confinement (see \fdf{PAO!BasisType} \texttt{nodes} below).
  This construction was proposed and tested in D. S\'anchez-Portal
\textit{et al.}, J. Phys.: Condens. Matter \textbf{8}, 3859-3880 (1996).

  We found that the basis set convergence is slow, requiring high levels
of multiple-$\zeta$ to achieve what other schemes do at the double-$\zeta$
level.
  This scheme is related with the basis sets used in the OpenMX project
[see T. Ozaki, Phys. Rev. B \textbf{67}, 155108 (2003); T. Ozaki and H. Kino,
Phys. Rev. B \textbf{69}, 195113 (2004)].

  We then proposed an extension of the split valence idea of Quantum Chemistry
to strictly localized NAO which has become the standard and has been used
quite successfully in many systems (see \fdf{PAO!BasisType} \texttt{split} below).
  It is based on the idea of suplementing the first $\zeta$ with, instead of
a gaussian, a numerical orbital that reproduces the tail of the original PAO
outside a matching radius $r_{m}$, and continues smoothly towards the origin as
$r^l(a-br^2)$, with $a$ and $b$ ensuring continuity and differentiability
at $r_{m}$.
  Within exactly the same
Hilbert space, the second orbital can be chosen to be the difference between
the smooth one and the original PAO, which gives a basis orbital strictly
confined within the matching radius $r_{m}$ (smaller than the
original PAO!) continuously differentiable throughout.

  Extra parameters have thus appeared: one $r_m$ per orbital to be doubled.
The user can again introduce them by hand (see \fdf{PAO!Basis} below).
Alternatively, all the $r_m$'s can be defined at once by specifying
the value of the tail of the original PAO beyond $r_m$, the so-called
split norm. Variational optimization
of this split norm performed on different systems
shows a very general and stable performance for values around
15\% (except for the $\sim 50\%$ for hydrogen).
  It generalizes to multiple-$\zeta$ trivially by adding an additional
  matching radius per new zeta.

Note: In previous versions of the program what was actually used as
split-valence reference was the norm of the tail \emph{plus} the norm of the
parabola-like inner function.

Angular flexibility is obtained by adding shells of higher angular
momentum.  Ways to generate these so-called polarization orbitals have
been described in the literature for Gaussians.  For NAOs there are
two ways for \siesta\ and \program{Gen-basis} to generate them: $(i)$
Use atomic PAO's of higher angular momentum with suitable confinement,
and $(ii)$ solve the pseudoatom in the presence of an electric field
and obtain the $l+1$ orbitals from the perturbation of the $l$
orbitals by the field. Experience shows that method $(i)$ tends to
give better results.

So-called diffuse orbitals, that might be important in the description
of open systems such as surfaces, can be simply added by specifying
extra ``n'' shells. [See S. Garcia-Gil, A. Garcia, N. Lorente,
  P. Ordejon, Phys. Rev. B \textbf{79}, 075441 (2009)]

Finally, the method allows the inclusion of off-site (ghost) orbitals
(not centered around any specific atom), useful for example in the
calculation of the counterpoise correction for basis-set superposition
errors.  Bessel functions for any radius and any excitation level can
also be added anywhere to the basis set.

\textbf{Range:} cutoff radii of orbitals.

Strictly localized orbitals (zero beyond a cutoff radius) are used in
order to obtain sparse Hamiltonian and overlap matrices for linear
scaling. One cutoff radius per angular momentum channel has to be
given for each species.

A balanced and systematic starting point for defining all the
different radii is achieved by giving one single parameter, the energy
shift, i.e., the energy increase experienced by the orbital when confined.
Allowing for system and physical-quantity variablity, as a rule of
thumb $\Delta E_{\mathrm{PAO}} \approx 100$ meV gives typical
precisions within the accuracy of current GGA functionals.  The user
can, nevertheless, change the cutoff radii at will.

\textbf{Shape}

Within the pseudopotential framework it is important to keep the
consistency between the pseudopotential and the form of the
pseudoatomic orbitals in the core region.  The shape of the orbitals
at larger radii depends on the cutoff radius (see above) and on the
way the localization is enforced.

The first proposal (and quite a standard among \siesta\ users)
uses an infinite square-well potential.  It was originally proposed
and has been widely and successfully used by Otto Sankey and
collaborators, for minimal bases within the ab initio tight-binding
scheme, using the \program{Fireball} program, but also for more flexible
bases using the methodology of \siesta.  This scheme has the
disadavantage, however, of generating orbitals with a discontinuous
derivative at $r_c$.  This discontinuity is more pronounced for
smaller $r_c$'s and tends to disappear for long enough values of this
cutoff.  It does remain, however, appreciable for sensible values of
$r_c$ for those orbitals that would be very wide in the free atom.  It
is surprising how small an effect such a kink produces in the total
energy of condensed systems.  It is, on the other hand, a problem for
forces and stresses, especially if they are calculated using a
(coarse) finite three-dimensional grid.

Another problem of this scheme is related to its defining the basis
starting from the free atoms.  Free atoms can present extremely extended
orbitals, their extension being, besides problematic, of no practical
use for the calculation in condensed systems: the electrons far away
from the atom can be described by the basis functions of other atoms.

A traditional scheme to deal with this is one based on the radial
scaling of the orbitals by suitable scale factors.  In addition to
very basic bonding arguments, it is soundly based on restoring
the virial's theorem for finite bases, in the case of Coulombic potentials
(all-electron calculations).  The use of pseudopotentials limits its
applicability, allowing only for extremely small deviations from unity
($\sim 1\%$) in the scale factors obtained variationally (with the
exception of hydrogen that can contract up to 25\%). This possiblity
is available to the user.

Another way of dealing with the above problem and that of the kink at the
same time is adding a soft confinement potential to the atomic
Hamiltonian used to generate the basis orbitals: it smoothens the kink
and contracts the orbital as suited. Two additional parameters are
introduced for the purpose, which can be defined again variationally.
The confining potential is flat (zero) in the core region, starts off
at some internal radius $r_i$ with all derivatives continuous and
diverges at $r_c$ ensuring the strict localization there.  It is
\begin{equation}
  V(r) = V_{\mathrm o} \frac{e^{- { \frac{r_c - r_i}{r - r_i} } }}{r_c -r}
\end{equation}
and both $r_i$ and $V_{\mathrm o}$ can be given to \siesta\ together
with $r_c$ in the input (see \fdf{PAO!Basis} below).
The kink is normally well smoothened with the default values
for soft confinement by default (\fdf{PAO!SoftDefault} true), which
are $r_i = 0.9 r_c$ and $V_{\mathrm o} = 40\,\mathrm{Ry}$.

When explicitly introducing orbitals in the basis that would be empty in
the atom (e.g. polarisation orbitals) these tend to be extremely
extended if not completely unbound. The above procedure produces
orbitals that bulge as far away from the nucleus as possible, to
plunge abruptly at $r_c$. Soft confinement can be used to try
to force a more reasonable shape, but it is not ideal (for orbitals
peaking in the right region the tails tend to be far too short).
\textit{Charge confinement} \index{Charge confinement} produces
very good shapes for empty orbitals. Essentially a $Z/r$ potential
is added to the soft confined potential above. For flexibility
the charge confinement option in \siesta\ is defined as
\begin{equation}
  V_{\mathrm Q}(r) = \frac{Z e^{-\lambda r}}{\sqrt{r^2 + \delta^2}}
\end{equation}
where $\delta$ is there to avoid the singularity (default $\delta=0.01$ Bohr),
and $\lambda$ allows to screen the potential if longer tails are needed.
The description on how to introduce this option can be found in
the \fdf{PAO!Basis} entry below.

Finally, the shape of an orbital is also changed by the ionic
character of the atom.  Orbitals in cations tend to shrink, and they
swell in anions.  Introducing a $\delta Q$ in the basis-generating
free-atom calculations gives orbitals better adapted to ionic
situations in the condensed systems.

More information about basis sets can be found in the proposed
literature.


\noindent

There are quite a number of options for the input of the basis-set and
KB projector specification, and they are all optional! By default,
\siesta\ will use a DZP basis set with appropriate choices for the
determination of the range, etc. Of course, the more you experiment
with the different options, the better your basis set can get. To aid
in this process we offer an auxiliary program for optimization which
can be used in particular to obtain variationally optimal basis sets
(within a chosen basis size). See \texttt{Util/Optimizer}
for general information, and \texttt{Util/Optimizer/Examples/Basis\_Optim}
for an example. The directory \texttt{Tutorials/Bases} in the main \siesta\
distribution contains some tutorial material for the generation of
basis sets and KB projectors.

Finally, some optimized basis sets for particular elements are
available at the \siesta\ web page.  Again, it is the
responsability of the users to test the transferability of the basis
set to their problem under consideration.


\subsubsection{Type of basis sets}

\begin{fdfentry}{PAO!BasisType}[string]<split>
  \index{basis!PAO}

  The kind of basis to be generated is chosen. All are based on
  finite-range pseudo-atomic orbitals\index{finite-range pseudo-atomic
      orbitals} [PAO's of Sankey and Niklewsky, PRB 40, 3979
  (1989)]. The original PAO's were described only for minimal
  bases. \siesta\ generates extended bases
  (multiple-$\zeta$,\index{multiple-$\zeta$}
  polarization,\index{polarization orbitals} and diffuse
  orbitals\index{diffuse orbitals}) applying different schemes of
  choice:

  \begin{itemize}

    \item[-] Generalization of the PAO's: uses the excited orbitals of
    the finite-range pseudo-atomic problem, both for multiple-$\zeta$
    and for polarization [see S\'anchez-Portal, Artacho, and Soler,
    JPCM \textbf{8}, 3859 (1996)]. Adequate for short-range orbitals.

    \item[-] Multiple-$\zeta$ in the spirit of split
    valence,\index{split valence} decomposing the original PAO in
    several pieces of different range, either defining more (and
    smaller) confining radii, or introducing
    Gaussians\index{Gaussians} from known bases (Huzinaga's book).

  \end{itemize}

  \noindent
  All the remaining options give the same minimal basis\index{minimal
      basis}. The different options and their \fdflib\ descriptors are
  the following:

  \begin{fdfoptions}

    \option[split]%
    \fdfindex*{PAO!BasisType:split}%

    Split-valence scheme for multiple-zeta.
    The split is based on different radii.


    \option[splitgauss]%
    \fdfindex*{PAO!BasisType:splitgauss}%

    Same as \texttt{split} but using gaussian functions
    $e^{-(x/\alpha_i)^2}$. The gaussian widths $\alpha_i$ are read
    instead of the scale factors (see below). There is no cutting
    algorithm, so that a large enough $r_c$ should be defined for the
    gaussian to have decayed sufficiently.


    \option[nodes]%
    \fdfindex*{PAO!BasisType:nodes}%

    Generalized PAO's.


    \option[nonodes]%
    \fdfindex*{PAO!BasisType:nonodes}%

    The original PAO's are used, multiple-zeta is generated by
    changing the scale-factors, instead of using the excited orbitals.


    \option[filteret]
    \fdfindex*{PAO!BasisType:filteret}%

    Use the filterets as a systematic basis set.  The size of the
    basis set is controlled by the filter cut-off for the orbitals.

  \end{fdfoptions}

  \noindent
  Note that, for the \fdf*{split} and \fdf*{nodes} cases the whole
  basis can be generated by \siesta\ with no further information
  required. \siesta\ will use default values as defined in the
  following (\fdf{PAO!BasisSize}, \fdf{PAO!EnergyShift}, and
  \fdf{PAO!SplitNorm}, see below).

\end{fdfentry}


\subsubsection{Size of the basis set}

\begin{fdfentry}{PAO!BasisSize}[string]<DZP>
  \index{basis!PAO}

  It defines usual basis sizes. It has effect only if there is no
  block \fdf{PAO!Basis} present.

  \begin{fdfoptions}

    \option[SZ|minimal]%
    \fdfindex*{PAO!BasisSize:SZ}%
    \fdfindex*{PAO!BasisSize:minimal}%
    \index{basis!minimal}
    \index{single-$\zeta$}

    Use single-$\zeta$ basis.


    \option[DZ]%
    \fdfindex*{PAO!BasisSize:DZ}%
    \index{double-$\zeta$}

    Double zeta basis, in the scheme defined by \fdf{PAO!BasisType}.


    \option[SZP]%
    \fdfindex*{PAO!BasisSize:SZP}%

    Single-zeta basis plus polarization orbitals.


    \option[DZP|standard]%
    \fdfindex*{PAO!BasisSize:DZP}%

    Like \fdf*{DZ} plus polarization orbitals.

  \end{fdfoptions}

  \note The ground-state atomic configuration used internally by
    \siesta\ is defined in the source file
    \shell{Src/periodic\_table.f}.  For some elements (e.g., Pd), the
    configuration might not be the standard one\index{Ground-state
        atomic configuration}.

    \note By default, polarization orbitals
    are constructed from perturbation theory,\index{perturbative
        polarization} and they are defined so they
    have\index{basis!polarization} the minimum angular momentum $l$
    such that there are no occupied orbitals with the same $l$ in the
    valence shell of the ground-state atomic configuration. They
    polarize the corresponding $l-1$ shell.

    See \fdf{PAO!Polarization!NonPerturbative} and
    \fdf{PAO!Polarization!Scheme} in Sec.~\ref{sec:non-pert-pols} for
    options to generate polarization orbitals non-perturbatively.

\end{fdfentry}


\begin{fdfentry}{PAO!BasisSizes}[block]
  \index{basis!PAO}

  Block which allows to specify a different value of the variable
  \fdf{PAO!BasisSize} for each species. For example,
  \begin{fdfexample}
     %block PAO.BasisSizes
         Si      DZ
         H       DZP
         O       SZP
     %endblock PAO.BasisSizes
  \end{fdfexample}

\end{fdfentry}



\subsubsection{Range of the orbitals}

\begin{fdfentry}{PAO!EnergyShift}[energy]<$0.01\,\mathrm{Ry}$>

  A standard for orbital-confining cutoff radii. It is the excitation
  energy of the PAO's due to the confinement to a finite-range. It
  offers a general procedure for defining the confining radii of the
  original (first-zeta) PAO's for all the species guaranteeing the
  compensation of the basis. It only has an effect when the block
  \fdf{PAO!Basis} is not present or when the radii specified in
  that block are zero for the first zeta.

\end{fdfentry}


\begin{fdfentry}{Write!Graphviz}[string]<none|atom|orbital|atom+orbital>

  Write out the sparsity pattern after having determined the basis
  size overlaps. This will generate \sysfile{ATOM.gv} or
  \sysfile{ORB.gv} which both may be converted to a graph using
  Graphviz's program \program{neato}:
  \begin{shellexample}
    neato -x -Tpng siesta.ATOM.gv -o siesta_ATOM.png
  \end{shellexample}
  The resulting graph will list each atom as $i (j)$ where $i$ is the
  atomic index and $j$ is the number of other atoms it is connected
  to.

\end{fdfentry}


\subsubsection{Generation of multiple-zeta orbitals}

\begin{fdfentry}{PAO!SplitNorm}[real]<$0.15$>
  \fdfdepend{PAO!SplitTailNorm}
  \index{basis!split valence}

  A standard to define sensible default radii for the split-valence
  type of basis. It gives the amount of norm that the second-$\zeta$
  split-off piece has to carry. The split radius is defined
  accordingly. If multiple-$\zeta$\index{multiple-$\zeta$} is used,
  the corresponding radii are obtained by imposing smaller fractions
  of the SplitNorm (1/2, 1/4, 1/6 ...) value as norm carried by the higher
  zetas. It only has an effect when the block \fdf{PAO!Basis} is
  not present or when the radii specified in that block are zero for
  zetas higher than one.

  \note When using \fdf{PAO!SplitTailNorm:true} (the default as of
  \siesta\ V5) the mapping of split-norm parameters to radial matching
  points changes. Legacy values might have to be revised. See the
  longer note under \fdf{PAO!SplitTailNorm}.

\end{fdfentry}

\begin{fdfentry}{PAO!SplitNormH}[real]<\fdfvalue{PAO!SplitNorm}>
  \index{basis!split valence for H}

  This option is as per \fdf{PAO!SplitNorm} but allows a separate
  default to be specified for hydrogen which typically needs larger
  values than those for other elements.

\end{fdfentry}

\begin{fdflogicalT}{PAO!SplitTailNorm}
  \index{basis!new split-valence code}

  Use the norm of the tail instead of the ``tail+parabola'' norm to
  compute the ``split'' contribution.  This is the behavior described
  in the JPC paper, but for numerical reasons the square
  root of the tail norm is used in the algorithm. This approach guarantees
  a match for any value of the \fdf{PAO!SplitNorm} parameter, and is the
  preferred mode of operation.

  \note For a given value of \fdf{PAO!SplitNorm} one can find these
  two cases, depending on the setting of this option:

  \begin{description}
    \item[\fdftrue] the cutoff lengths of the higher $\zeta$ orbitals will be shorter

      The split-norm curve (square root of the tail norm) approaches $0$
      faster in this case, hence the matching radius is found at a
      shorter distance.

    \item[\fdffalse] the cutoff lengths of the higher $\zeta$ orbitals will be longer

      The (tail+parabola) norm is used as the split-norm
      reference. This curve \emph{likely} approaches $0$ more slowly
      (or not at all), hence the matching radius is found at a longer
      distance.

  \end{description}

\end{fdflogicalT}

\begin{fdflogicalF}{PAO!SplitValence!Legacy}
  Recovers the behavior and default settings of the legacy split-valence options.
  In addition to {PAO!SplitTailNorm}, which would be \fdffalse\ by default, users can
  set the option {PAO!FixSplitTable} (see below).
\end{fdflogicalF}


\begin{fdflogicalF}{PAO!FixSplitTable}
  \index{basis!fix split-valence table}

  After the scan of the (tail+parabola) norm table (curve), apply a damping
  function to the tail to make sure that the table goes to zero at the
  radius of the first-zeta orbital.  \fdf{PAO!FixSplitTable:true}
  guarantees that the program finds a solution, even when using the
  tail+parabola split-norm heuristic. The result might not be optimal (in the
  sense of producing a second-$\zeta$ $r_c$ very close to the
  first-$\zeta$ one).

  This option is not accessible with {PAO!SplitValence!Legacy:false}.

\end{fdflogicalF}


\begin{fdfentry}{PAO!EnergyCutoff}[energy]<$20\,\mathrm{Ry}$>

  If the multiple zetas are generated using filterets then only the
  filterets with an energy lower than this cutoff are
  included. Increasing this value leads to a richer basis set
  (provided the cutoff is raised above the energy of any filteret that
  was previously not included) but a more expensive calculation.  It
  only has an effect when the option \fdf{PAO!BasisType} is set to
  \fdf*{filteret}.

\end{fdfentry}

\begin{fdfentry}{PAO!EnergyPolCutoff}[energy]<$20\,\mathrm{Ry}$>

  If the multiple zetas are generated using filterets then only the
  filterets with an energy lower than this cutoff are included for the
  polarisation functions. Increasing this value leads to a richer
  basis set (provided the cutoff is raised above the energy of any
  filteret that was previously not included) but a more expensive
  calculation. It only has an effect when the option
  \fdf{PAO!BasisType} is set to filteret.

\end{fdfentry}

\begin{fdfentry}{PAO!ContractionCutoff}[real]<$0$|$0-1$>

  If the multiple zetas are generated using filterets then any
  filterets that have a coefficient less than this threshold within
  the original PAO will be contracted together to form a single
  filteret.  Increasing this value leads to a smaller basis set but
  allows the underlying basis to have a higher kinetic energy cut-off
  for filtering. It only has an effect when the option
  \fdf{PAO!BasisType} is set to \fdf*{filteret}.

\end{fdfentry}

\subsubsection{Polarization-orbital options}
\label{sec:non-pert-pols}

Polarization orbitals can be requested through an automatic basis-size
specification such as DZP, or TZP, etc, or through the use of the 'P'
shell option in the \fdf{PAO!Basis} block.

In these cases, by default, polarization orbitals are generated
perturbatively, by formally applying an electric field to the orbital
being polarized.

Polarization shells can also be put explicitly in the \fdf{PAO!Basis}
block. In this case, the orbitals are generated in the standard way,
using the appropriate confinement and split-norm options.

If the perturbative method is not wanted, even when using the standard
basis specifications, the following global option
can be used:

\begin{fdflogicalF}{PAO!Polarization!NonPerturbative}
  \index{basis!polarization orbitals}

  If enabled, it will promote any polarization shells to the status
  of explicit shells, thus using the standard generation options.

\end{fdflogicalF}

Also, this setting can be controlled species by species, by using
a block

\begin{fdfentry}{PAO!Polarization!Scheme}[block]
  \index{basis!polarization orbitals}

  Block which allows to specify a different polarization scheme
  for each species. For example,
  \begin{fdfexample}
     %block PAO.Polarization.Scheme
         Si      non-perturbative  [ optional Q options]
         H       perturbative
     %endblock PAO.Polarization.Scheme
  \end{fdfexample}

  The presence of 'perturbative' for a species in the block has
  the effect of \emph{forcing} the use of the perturbative option.

  If a species does not appear in the block, the setting of
  \fdf{PAO!Polarization!NonPerturbative} applies.
  The default scheme is perturbative.

  An optional charge-confinement specification can follow, starting
  with a 'Q', in exactly the same way as in the \fdf{PAO!Basis} block.

\end{fdfentry}

The perturbative method does not require any extra information
regarding confinement, since the $r_c$ value for the polarization
shell is the same as the one for the polarized shell.  If the
perturbative method is turned off, the new explicit shell created for
the polarization orbital will be assigned an $r_c$ equal to the one
actually used for the shell to be polarized (for the 1st zeta). The only
extra control offered at this point is a possible expansion of this
value through the (global) option:

\begin{fdfentry}{PAO!Polarization!Rc-Expansion-Factor}[real]<$1.0$>
  \index{basis!confinement radius expansion}

  When turning off the perturbative method for the generation of
  polarization orbitals, assign to the 1st zeta of the explicit
  polarization shell the $r_c$ of the polarized shell multiplied by
  this factor.

\end{fdfentry}

Note that, empirically, the perturbative method seems to give better
results (in the variational sense), so the alternative should only be
used when the default fails for some reason, for full basis-set optimization,
or for experimentation purposes. In particular, non-perturbatively
generated polarization orbitals tend to bulge outwards. To correct
this, the charge-confinement options in the \fdf{PAO!Basis} block (or
in the \fdf{PAO!Polarization!Scheme} block) might be helpful.

There is one case, however, which tends to exhibit problems in the
perturbative algorithm: when a polarization orbital has to have a node
due to the presence of a lower-lying orbital of the same $l$ (this
will happen, for example, for Ge if the $3d$ orbital is considered
part of the valence). In this case, the program can automatically
switch to using the non-perturbative scheme.  To enable this automatic
switch, the option \fdf{PAO!Polarization!NonPerturbative.Fallback}
must be enabled (it is by default). Note that if the 'perturbative' option is explicitly
set in the block above, the fallback is overriden.

A proper basis-set optimization should be carried out using
a \fdf{PAO!Basis} block, which allows a full set of options.


\subsubsection{Soft-confinement options}
A brief description of the soft-confinement options is given below. This is
the default way of generating basis orbitals, and disabling it is not
recommended unless going for backwards compatibility.
The default potential and inner radius options should not be changed
either, except when needed for an specific application.


\begin{fdflogicalT}{PAO!SoftDefault}
  \index{basis!default soft confinement}
  This option causes soft confinement to be the default form of potential during
  orbital generation. Disabling this will cause a fallback to the original
  hard-confined orbitals.

\end{fdflogicalT}

\begin{fdfentry}{PAO!SoftInnerRadius}[real]<$0.9$>
  \index{basis!default soft confinement radius}

  For default soft confinement, the inner radius is set at a fraction
  of the outer confinement radius determined by the energy shift. This
  option controls the fraction of the confinement radius to be used.

\end{fdfentry}

\begin{fdfentry}{PAO!SoftPotential}[energy]<$40\,\mathrm{Ry}$>
  \index{basis!default soft confinement potential}

  For default soft confinement, this option controls the value of the
  potential used for all orbitals.

  \note Soft-confinement options (inner radius, prefactor) have been
  traditionally used to optimize the basis set, even though formally
  they are just a technical necessity to soften the decay of the
  orbitals at rc. To achieve this, it might be enough to use the above
  global options.

\end{fdfentry}


\subsubsection{Kleinman-Bylander projectors}

\index{PSML}{\index{Kleinman-Bylander projectors!from PSML file} NOTE:
  \siesta\ is now able to read directly the non-local projectors
  from a PSML file. For this, the options \fdf{PSML!Vlocal} and
  \fdf{PSML!KB.projectors} must be set to \fdftrue (they are by default), and a
  \shell{Chemical\_label.psml} file must be present. The rest of the
  options discussed in this section will have no effect in that case.
}

\begin{fdfentry}{PS!lmax}[block]

  Block with the maximum angular momentum of the Kleinman-Bylander
  projectors,\index{Kleinman-Bylander projectors} \texttt{lmxkb}.
  This information is optional. If the block is absent, or for a
  species which is not mentioned inside it, \siesta\ will take
  \texttt{lmxkb(is) = lmxo(is) + 1}, where \texttt{lmxo(is)} is the
  maximum angular momentum of the basis orbitals of species
  \texttt{is}.
However, the value of \texttt{lmxkb} is actually
limited by the highest-l channel in the pseudopotential file.
  \begin{fdfexample}
      %block Ps.lmax
          Al_adatom   3
          H           1
          O           2
      %endblock Ps.lmax
  \end{fdfexample}

By default \texttt{lmax} is the maximum angular momentum plus one,
limited by the highest-l channel
in the pseudopotential file.
\end{fdfentry}


\begin{fdfentry}{PS.KBprojectors}[block]

This block provides information about the number of Kleinman-Bylander
projectors per angular momentum that will used in the
calculation. This block is optional.  If it is absent, or for species
not mentioned in it, only one projector will be used for each angular
momentum (except for l-shells with semicore states, for which two
projectors will be constructed). The projectors will be constructed
using the eigenfunctions of the respective pseudopotentials.

This block allows to specify also the reference energies of the
wavefunctions used to build them.  The specification of the reference
energies is optional. If these energies are not given, the program
will use the eigenfunctions with an increasing number of nodes (if
there is not bound state with the corresponding number of nodes, the
``eigenstates'' are taken to be just functions which are made zero at
very long distance of the nucleus).  The units for the energy can be
optionally specified; if not, the program will assumed that they are
given in Rydbergs.  The data provided in this block must be consistent
with those read from the block \fdf{PS!lmax}. For example,

\begin{verbatim}
         %block PS.KBprojectors
             Si  3
              2   1
             -0.9     eV
              0   2
             -0.5  -1.0d4 Hartree
              1   2
             Ga  1
              1  3
             -1.0  1.0d5 -6.0
         %endblock PS.KBprojectors
\end{verbatim}

The reading is done this way (those variables in brackets are optional,
therefore they are only read if present):

\begin{verbatim}
 From is = 1 to  nspecies
     read: label(is), l_shells(is)
     From lsh=1 to l_shells(is)
         read: l, nkbl(l,is)
         read: {erefKB(izeta,il,is)}, from ikb = 1 to nkbl(l,is), {units}
\end{verbatim}

All angular momentum shells should be specified.  Default values are
assigned to missing shells with $l$ below lmax, where lmax is the
highest angular momentum present in the block for that particular
species. High-l shells (beyond lmax) not specified in the block will
also be assigned default values.

Care should be taken for l-shells with semicore states. For them, two
KB projectors should be generated. This is not checked while
processing this block.

When a very high energy, higher that 1000 Ry, is specified, the
default is taken instead.  On the other hand, very low (negative)
energies, lower than -1000 Ry, are used to indicate that the energy
derivative of the last state must be used. For example, in the block
given above, two projectors will be used for the $s$
pseudopotential of Si. One generated using a reference energy of -0.5
Hartree, and the second one using the energy derivative of this
state. For the $p$ pseudopotential of Ga, three projectors will be
used.  The second one will be constructed from an automatically
generated wavefunction with one node, and the other projectors from
states at -1.0 and -6.0 Rydberg.

The analysis looking for possible \textit{ghost} states is only performed
when a single projector is used.  Using several projectors some
attention should be paid to the ``KB cosine'' (kbcos), given in the
output of the program.  The KB cosine gives the value of the overlap
between the reference state and the projector generated from it.  If
these numbers are very small ( $<$ 0.01, for example) for \textbf{all}
the projectors of some angular momentum, one can have problems related
with the presence of ghost states.

The default is \emph{one} KB projector from each angular momentum,
constructed from the nodeless eigenfunction, used for each angular
momentum, except for l-shells with semicore states, for which two
projectors will be constructed.
Note that the value of \texttt{lmxkb} is actually limited by the
highest-l channel in the pseudopotential file.

For full spin-orbit calculations, the program generates $lj$
projectors using the $l+1/2$ and $l-1/2$ components of the
(relativistic) pseudopotentials. In this case the specification of the
reference energies for projectors is not changed: only $l$ is
relevant. Fully relativistic projectors can also be read from a
suitably generated PSML file.

\end{fdfentry}


\begin{fdflogicalF}{KB.New.Reference.Orbitals}

  If \fdftrue, the routine to generate KB projectors will use slightly
  different parameters for the construction of the reference orbitals
  involved (\shell{Rmax=60} Bohr both for integration and normalization).

\end{fdflogicalF}


\subsubsection{The PAO.Basis block}

\begin{fdfentry}{PAO!Basis}[block]
  \index{basis!PAO}

  Block with data to define explicitly the basis to be used.  It
  allows the definition by hand of all the parameters that are used to
  construct the atomic basis. There is no need to enter information
  for all the species present in the calculation. The
  basis\index{basis!PAO} for the species not mentioned in this block
  will be generated automatically using the parameters
  \fdf{PAO!BasisSize}, \fdf{PAO!BasisType}, \fdf{PAO!EnergyShift},
  \fdf{PAO!SplitNorm} (or \fdf{PAO!SplitNormH}), and the
  soft-confinement defaults (see \fdf{PAO!SoftDefault}).

  \textbf{NOTE}: This block gives full control to the user, and with that
  comes the user's responsibility of making sure that the contents of
  the block are appropriate. This is particularly important for the
  specification of the PAO shells to be included in the basis set. Some
  pseudopotentials are generated with semicore states, which should
  be included in the basis set. Conversely, a \fdf{PAO!Basis} block prepared
  for a species with semicore states will not work for the same chemical
  element if employing a pseudopotential without them. As a suggestion,
  users might want to try first a run in ``automatic mode'' (i.e. without
  using a \fdf{PAO!Basis} block) just to check which basis-set shells are identified by
  the built-in heuristics in the program. Then the skeleton \fdf{PAO!Basis}
  produced might be fully fleshed out according to the user's needs.

  Some parameters can be set to zero, or left out completely.  In
  these cases the values will be generated from the magnitudes defined
  above, or from the appropriate default values. For example, the
  radii\index{cutoff radius} will be obtained from
  \fdf{PAO!EnergyShift} or from \fdf{PAO!SplitNorm} if they are
  zero; the scale factors will be put to 1 if they are zero or not
  given in the input.  An example block for a two-species calculation
  (H and O) is the following (\texttt{opt} means optional):

  \begin{fdfexample}
%block PAO.Basis     # Define Basis set
O    2  nodes  1.0   # Label, l_shells, type (opt), ionic_charge (opt)
 n=2 0 2  E 50.0 2.5 # n (opt if not using semicore levels),l,Nzeta,Softconf(opt)
     3.50  3.50      #     rc(izeta=1,Nzeta)(Bohr)
     0.95  1.00      #     scaleFactor(izeta=1,Nzeta) (opt)
     1 1  P 2        # l, Nzeta, PolOrb (opt), NzetaPol (opt)
     3.50            #     rc(izeta=1,Nzeta)(Bohr)
H    2               # Label, l_shells, type (opt), ionic_charge (opt)
     0 2 S 0.2       # l, Nzeta, Per-shell split norm parameter
     5.00  0.00      #     rc(izeta=1,Nzeta)(Bohr)
     1 1 Q 3. 0.2    # l, Nzeta, Charge conf (opt): Z and screening
     5.00            #    rc(izeta=1,Nzeta)(Bohr)
%endblock PAO.Basis
  \end{fdfexample}


  \noindent
  The reading is done this way (those variables in brackets are
  optional, therefore they are only read if present) (See
  the routines in \shell{Src/basis\_specs.f} for detailed information):

\begin{shellexample}
    From js = 1 to  nspecies
       read: label(is), l_shells(is), { type(is) }, { ionic_charge(is) }
       From lsh=1 to l_shells(is)
        read:
         { n }, l(lsh), nzls(lsh,is), { PolOrb(l+1) }, { NzetaPol(l+1) },
         {SplitNormfFlag(lsh,is)}, {SplitNormValue(lsh,is)}
         {SoftConfFlag(lsh,is)}, {PrefactorSoft(lsh,is)}, {InnerRadSoft(lsh,is)},
         {FilteretFlag(lsh,is)}, {FilteretCutoff(lsh,is)}
         {ChargeConfFlag(lsh,is)}, {Z(lsh,is)}, {Screen(lsh,is)}, {delta(lsh,is}
           read: rcls(izeta,lsh,is), from izeta = 1 to nzls(l,is)
           read: { contrf(izeta,il,is) }, from izeta = 1 to nzls(l,is)
\end{shellexample}

  \noindent
  And here is the variable description:
  \begin{itemize}
    \item[-] %
    \texttt{Label}: Species label, this label determines
    the species index \texttt{is} according to the block
    \fdf{ChemicalSpeciesLabel}

    \item[-]%
    \texttt{l\_shells(is)}: Number of shells of orbitals
    with different angular momentum for species \texttt{is}

    \item[-]%
    \texttt{type(is)}: \textit{Optional input}.  Kind of basis set
    generation procedure for species \texttt{is}.  Same options as
    \fdf{PAO!BasisType}

    \item[-]%
    \texttt{ionic\_charge(is)}: \textit{Optional input}.  Net charge
    of species \texttt{is}. This is only used for basis set generation
    purposes. \textit{Default value}: \texttt{0.0} (neutral
    atom). Note that if the pseudopotential was generated in an ionic
    configuration, and no charge is specified in PAO.Basis, the ionic
    charge setting will be that of pseudopotential generation.

    \item[-]%
    \texttt{n}: Principal quantum number of the shell. This is an
    optional input for normal atoms, however it must be specified when
    there are \textit{semicore} states (i.e. when states that usually
    are not considered to belong to the valence shell have been
    included in the calculation)

    \item[-]%
    \texttt{l}: Angular momentum of basis orbitals of this shell

    \item[-]%
    \texttt{nzls(lsh,is)}: Number of ``zetas'' for this shell. For a
    filteret basis this number is ignored since the number is
    controlled by the cutoff.
    For bessel-floating orbitals, the different 'zetas' map to
    increasingly excited states with the same angular momentum (with
    increasing number of nodes).


    \item[-]%
    \texttt{PolOrb(l+1)}: \textit{Optional input}. If set equal to
    \texttt{P}, a shell of polarization functions (with angular
    momentum $l+1$) will be constructed from the first-zeta orbital of
    angular momentum $l$. \textit{Default value}: ' ' (blank = No
    polarization orbitals).

    \item[-]%
    \texttt{NzetaPol(l+1)}: \textit{Optional input}. Number of
    ``zetas'' for the polarization shell (generated automatically in a
    split-valence fashion).  For a filteret basis this number is
    ignored since the number is controlled by the cutoff.  Only active
    if \texttt{PolOrb = P}. \textit{Default value}: \texttt{1}

    \item[-]%
    \texttt{SplitNormFlag(lsh,is)}:\index{basis!per-shell split norm}
    \textit{Optional input}. If set equal to \texttt{S}, the following
    number sets the split-norm parameter for that shell.

    \item[-]%
    \texttt{SoftConfFlag(l,is)}:\index{basis!soft confinement
        potential} \textit{Optional input}. If set equal to
    \texttt{E}, the soft confinement potential proposed in equation
    (1) of the paper by J. Junquera \textit{et al.}, Phys. Rev. B
    \textbf{64}, 235111 (2001), is used instead of the Sankey
    hard-well potential.

    \item[-]%
    \texttt{PrefactorSoft(l,is)}: \textit{Optional input}. Prefactor
    of the soft confinement potential ($V_{0}$ in the formula). Units
    in Ry.  \textit{Default value}: 0 Ry.

    \item[-]%
    \texttt{InnerRadSoft(l,is)}: \textit{Optional input}. Inner radius
    where the soft confinement potential starts off ($r_{i}$ in the
    formula).  If negative, the inner radius will be computed as the
    given fraction of the PAO cutoff radius.  Units in
    bohrs. \textit{Default value}: 0 bohrs.

    \item[-]%
    \texttt{FilteretFlag(l,is)}:\index{basis!filteret basis set}
    \textit{Optional input}. If set equal to \texttt{F}, then an
    individual filter cut-off can be specified for the shell.

    \item[-]%
    \texttt{FilteretCutoff(l,is)}: \textit{Optional
        input}. Shell-specific value for the filteret basis
    cutoff. Units in Ry.  \textit{Default value}: The same as the
    value given by \fdf{FilterCutoff}.

    \item[-]%
    \texttt{ChargeConfFlag(lsh,is)}: \textit{Optional input}. If set
    equal to \texttt{Q}, the charge confinement potential in equation
    (2) above is added to the confining potential. If present it
    requires at least one number after it (\texttt{Z}), but it can be
    followed by two or three numbers.  \index{Charge confinement}

    \item[-]%
    \texttt{Z(lhs,is)}: \textit{Optional input, needed if \texttt{Q}
        is set}. $Z$ charge in equation (2) above for charge
    confinement (units of $e$).

    \item[-]%
    \texttt{Screen(lhs,is)}: \textit{Optional input}. Yukawa screening
    parameter $\lambda$ in equation (2) above for charge confinement
    (in Bohr$^{-1}$).

    \item[-]%
    \texttt{delta(lhs,is)}: \textit{Optional input}. Singularity
    regularisation parameter $\delta$ in equation (2) above for charge
    confinement (in Bohr).

    \item[-]%
    \texttt{rcls(izeta,l,is)}: Cutoff radius (Bohr) of each 'zeta' for
    this shell. For the second zeta onwards, if this value is
    negative, the actual rc used will be the given fraction of the
    first zeta's rc.
    If the number of rc's for a given shell is less than the number of
    'zetas', the program will assign the last rc value to the remaining
    zetas, rather than stopping with an error. This is particularly
    useful for Bessel suites of orbitals.

    \item[-]%
    \texttt{contrf(izeta,l,is)}: \textit{Optional input}.  Contraction
    factor\index{scale factor} of each ``zeta'' for this shell.
    If the number of entries for a given shell is less than the number of
    'zetas', the program will assign the last contraction value to the remaining
    zetas, rather than stopping with an error.
    \textit{Default value}: \texttt{1.0}
\end{itemize}

Polarization orbitals\index{perturbative
    polarization}\index{basis!polarization} are generated by solving
the atomic problem in the presence of a polarizing electric field. The
orbitals are generated applying perturbation theory to the first-zeta
orbital of lower angular momentum.  They have the same cutoff radius
as the orbitals from which they are constructed.

Note: The perturbative method has traditionally used the 'l' component
of the pseudopotential, but it can be argued that it should use the 'l+1'
component. The variable \fdf{PAO!OldStylePolOrbs} can be set to \fdftrue\
in order to enable the former method, but this is discouraged unless
testing for backwards compatibility.

There is a different possibility for generating polarization orbitals:
by introducing them explicitly in the \fdf{PAO!Basis} block (see
Sec.~\ref{sec:non-pert-pols} for full details).  It has to be
remembered, however, that they sometimes correspond to unbound states
of the atom, their shape depending very much on the cutoff radius, not
converging by increasing it, similarly to the multiple-zeta orbitals
generated with the \texttt{nodes} option.  Using \fdf{PAO!EnergyShift}
makes no sense, and a cut off radius different from zero must be
explicitly given (the same cutoff radius as the orbitals they polarize
is usually a sensible choice).

A species with atomic number = -100 will be considered by \siesta\ as
a constant-pseudopotential atom, \textit{i.e.}, the basis functions
generated will be spherical Bessel functions\index{Bessel functions}
with the specified $r_c$. In this case, $r_c$ has to be given, as
\fdf*{PAO.EnergyShift} will not calculate it.\index{basis!Bessel functions}

Other negative atomic numbers will be interpreted by \siesta\ as
\textit{ghosts}\index{ghost atoms}\index{basis!ghost atoms}
of the corresponding positive value: the orbitals
are generated and put in position as determined by the coordinates,
but neither pseudopotential nor electrons are considered for that
ghost atom. Useful for BSSE\index{basis!basis set superposition
error (BSSE)} correction.

\textit{Use:} This block is optional, except when Bessel functions
are present.

\textit{Default:} Basis characteristics defined by global definitions given
above.

\end{fdfentry}

\subsubsection{Filtering}
\label{sec:filtering}

\begin{fdfentry}{FilterCutoff}[energy]<$0\,\mathrm{eV}$>
  \index{basis!filtering}

  Kinetic energy cutoff of plane waves used to filter all the atomic
  basis functions, the pseudo-core densities for partial core
  corrections, and the neutral-atom potentials.  The basis functions
  (which must be squared to obtain the valence density) are really
  filtered with a cutoff reduced by an empirical factor
  $0.7^2 \simeq 0.5$. The \fdf{FilterCutoff} should be similar or
  lower than the \fdf{Mesh!Cutoff} to avoid the \emph{eggbox
      effect} on the atomic forces.  However, one should not try to
  converge \fdf{Mesh!Cutoff} while simultaneously changing
  \fdf{FilterCutoff}, since the latter in fact changes the used
  basis functions. Rather, fix a sufficiently large
  \fdf{FilterCutoff} and converge only \fdf{Mesh!Cutoff}.  If
  \fdf{FilterCutoff} is not explicitly set, its value is calculated
  from \fdf{FilterTol}.

\end{fdfentry}

\begin{fdfentry}{FilterTol}[energy]<$0\,\mathrm{eV}$>
  \index{basis!filtering}

  Residual kinetic-energy leaked by filtering each basis function.
  While \fdf{FilterCutoff} sets a common reciprocal-space cutoff for
  all the basis functions, \fdf{FilterTol} sets a specific cutoff for
  each basis function, much as the \fdf{PAO!EnergyShift} sets their
  real-space cutoff. Therefore, it is reasonable to use similar values
  for both parameters.  The maximum cutoff required to meet the
  \fdf{FilterTol}, among all the basis functions, is used (multiplied
  by the empirical factor $1/0.7^2 \simeq 2$) to filter the
  pseudo-core densities and the neutral-atom
  potentials. \fdf{FilterTol} is ignored if \fdf{FilterCutoff} is
  present in the input file.  If neither \fdf{FilterCutoff} nor
  \fdf{FilterTol} are present, no filtering is performed.  See
  \citet{SOLER20091134}, for details of the filtering procedure.

  \textbf{Warning:} If the value of \fdf{FilterCutoff} is made too
  small (or \fdf{FilterTol} too large) some of the filtered basis
  orbitals may be meaningless, leading to incorrect results or even a
  program crash.

  To be implemented: If \fdf{Mesh!Cutoff} is not present in the
  input file, it can be set using the maximum filtering cutoff used
  for the given \fdf{FilterTol} (for the time being, you can use
  \fdf{AtomSetupOnly} \fdftrue\ to stop the program after basis generation,
  look at the maximum filtering cutoff used, and set the mesh-cutoff
  manually in a later run.)

\end{fdfentry}



\subsubsection{Saving and reading basis-set information}

\index{basis}\index{output!basis}
\siesta\ (and the standalone program \textsc{Gen-basis})
\index{basis!Gen-basis standalone program}
always generate the files
\textit{Atomlabel}\texttt{.ion}, where \textit{Atomlabel} is the atomic label
specified in block \fdf{ChemicalSpeciesLabel}.  Optionally, if
NetCDF support is compiled in, the programs generate
NetCDF files \index{NetCDF format}
\textit{Atomlabel}\texttt{.ion.nc} (except for ghost atoms).
See an Appendix for information on the optional NetCDF package.

These files can be used to read back information into \siesta.

\begin{fdflogicalF}{User!Basis}
  \index{basis!User basis}

  If true, the basis, KB projector, and other information is read from
  files \textit{Atomlabel}\texttt{.ion}, where \textit{Atomlabel} is
  the atomic species label specified in block
  \fdf{ChemicalSpeciesLabel}. These files can be generated by a
  previous \siesta\ run or (one by one) by the standalone program
  \program{Gen-basis}.\index{Gen-basis
      program@\program{Gen-basis}}\index{basis!Gen-basis standalone
      program} No pseudopotential files are necessary.

\end{fdflogicalF}

\begin{fdflogicalF}{User!Basis.NetCDF}
  \index{basis!User basis (NetCDF format)}%
  \index{NetCDF format}%

  If true, the basis, KB projector, and other information is read from
  NetCDF files \textit{Atomlabel}\texttt{.ion.nc}, where
  \textit{Atomlabel} is the atomic label specified in block
  \fdf{ChemicalSpeciesLabel}. These files can be generated by a
  previous \siesta\ run or by the standalone program
  \program{Gen-basis}.\index{Gen-basis
      program@\program{Gen-basis}}\index{basis!Gen-basis standalone
      program} No pseudopotential files are necessary. NetCDF support
  is needed. Note that ghost atoms cannot yet be adequately treated
  with this option.

\end{fdflogicalF}



\subsubsection{Tools to inspect the orbitals and KB projectors}

The program \texttt{ioncat} in \texttt{Util/Gen-basis} can be used to
extract orbital, KB projector, and other information contained in the
\texttt{.ion} files. The output can be easily plotted with a graphics
program.  If the option \fdf{WriteIonPlotFiles} is enabled, \siesta\
will generate and extra set of files that can be plotted
with the \texttt{gnuplot} scripts in \texttt{Tutorials/Bases}.
The stand-alone program \texttt{gen-basis} sets that option by default, and
the script \texttt{Tutorials/Bases/gen-basis.sh} can be used to automate
the process. See also the NetCDF-based utilities in \texttt{Util/PyAtom}.

\subsubsection{Basis optimization}

There are quite a number of options for the input of the basis-set and
KB projector specification, and they are all optional! By default,
\siesta\ will use a DZP basis set with appropriate choices for the
determination of the range, etc. Of course, the more you experiment
with the different options, the better your basis set can get. To aid
in this process we offer an auxiliary program for optimization which
can be used in particular to obtain variationally optimal basis sets
(within a chosen basis size). See \texttt{Util/Optimizer}
for general information, and \texttt{Util/Optimizer/Examples/Basis\_Optim}
for an example.

\begin{fdfentry}{BasisPressure}[pressure]<$0.2\,\mathrm{GPa}$>
  \fdfdepend{BasisPressure.Specs}

  \siesta\ will compute and print the value of the ``effective basis
  enthalpy'' constructed by adding a term of the form
  $p_{basis}V_{orbs}$ to the total energy. Here $p_{basis}$ is a
  fictitious basis pressure and $V_{orbs}$ is the volume of the
  system's orbitals. This is a useful quantity for basis optimization
  (See Anglada \emph{et al.\/}). The total basis enthalpy is also
  written to the ASCII file \file{SystemLabel.BASIS\_ENTHALPY}.

\end{fdfentry}


If, instead, it's interesting to add a different basis pressure for each atomic
species, it's posible to do so via the \fdf{BasisPressure.Specs} option.

\begin{fdfentry}{BasisPressure.Specs}[block]
  \fdfdepend{BasisPressure}

  This will function similarly to \fdf{BasisPressure}, but using a different
  pressure for each atomic species. Within the block, there are three different
  ways to specify the pressure for each species:

  \begin{fdfexample}
    Z from <A> to <B> <pressure> <units>
    Z <A> <pressure> <units>
    <Species> <pressure> <units>
  \end{fdfexample}

  The first two lines rely on atomic numbers. The first line will set the
  pressure for all species with atomic numbers from <A> to <B> (inclusive),
  while the second line will set the pressure for a single species with atomic
  number <A>. Note the "Z" indicator for both lines. The third line is similar
  to the second, but it only uses the species label, which should coincide with
  a species defined in the \fdf{ChemicalSpeciesLabel} block.

  The lines within the block can be in any order, and they can be repeated as
  much as needed. If any species are not specified in this way, they will
  default to the value of \fdf{BasisPressure}.

  The following example will apply a pressure of 0.1 GPa to species with atomic
  numbers 1 to 10, 0.01 GPa to atomic number 14, and 0.3 GPa to species Cgga.

  \begin{fdfexample}
    %block BasisPressure.Specs
      Z from 1 to 10    0.1  GPa
      Z 14              0.01 GPa
      Cgga              0.3  GPa
    %endblock BasisPressure.Specs
  \end{fdfexample}
\end{fdfentry}

\subsubsection{Low-level options regarding the radial grid}

For historical reasons, the basis-set and KB projector code in
\siesta\ uses a logarithmic radial grid, which is taken from the
pseudopotential file. Any ``interesting'' radii have to fall on a grid
point, which introduces a certain degree of coarseness that can limit
the accuracy of the results and the faithfulness of the mapping of
input parameters to actual operating parameters. For example, the same
orbital will be produced by a finite range of \fdf{PAO!EnergyShift}
values, and any user-defined cutoffs will not be exactly reflected in
the actual cutoffs. This is particularly troublesome for automatic
optimization procedures (such as those implemented in
\texttt{Util/Optimizer}), as the engine might be confused by the extra
level of indirection. The following options can be used to fine-tune
the mapping.  Note that grid reparametrization is now
(at version 5) enabled by default, and it might change the
numerical results appreciably (in effect, it leads to slightly different basis
orbitals and projectors).

\begin{fdflogicalT}{Reparametrize.Pseudos}

  By changing the $a$ and $b$ parameters of the logarithmic grid, a new
  one with a more adequate grid-point separation can be used for the
  generation of basis sets and projectors. For example, by using
  $a=0.001$ and $b=0.01$, the grid point separations at $r=0$ and 10
  bohrs are 0.00001 and 0.01 bohrs, respectively. More points are needed
  to reach r's of the order of a hundred bohrs, but the extra
  computational effort is negligible.  The net effect of this option
  (notably when coupled to \fdf{Restricted.Radial.Grid})
  is a closer mapping of any user-specified cutoff radii and of the
  radii implicitly resulting from other input parameters to the actual
  values used by the program. (The small grid-point separation near r=0
  is still needed to avoid instabilities for s channels that occurred
  with the previous -reparametrized- default spacing of 0.005 bohr. This
  effect is not yet completely understood.)

\end{fdflogicalT}

\begin{fdfentry}{New!A.Parameter}[real]<$0.001$>
  \index{basis!reparametrization of pseudopotential}

  New setting for the pseudopotential grid's $a$ parameter

\end{fdfentry}

\begin{fdfentry}{New!B.Parameter}[real]<$0.01$>
  \index{basis!reparametrization of pseudopotential}

  New setting for the pseudopotential grid's $b$ parameter

\end{fdfentry}

\begin{fdfentry}{Rmax.Radial.Grid}[real]<$50.0$>
  \index{basis!point at infinity}

  New setting for the maximum value of the radial coordinate for
  integration of the atomic Schrodinger equation.

  If \fdf{Reparametrize.Pseudos} is \fdffalse\ this will be the
  maximum radius in the pseudopotential file.

\end{fdfentry}

\begin{fdflogicalT}{Restricted.Radial.Grid}

  In normal operation of the basis-set and projector generation code
  the various cutoff radii are restricted to falling on an
  odd-numbered grid point, shifting then accordingly. This restriction
  can be lifted by setting this parameter to \fdffalse.

\end{fdflogicalT}

\subsubsection{Summary of options and defaults enabling automatic basis-set generation}

In this section we review settings that can allow a fully automatic
basis-set generation, with minimal user input. Philosophically this
goes against the \siesta\ mindset of careful basis-set optimization,
but we must acknowledge the need for fully automatic, unattended,
operation for high-throughput computing.

Partly in response to this, some program defaults have changed in version 5 of \siesta.

\begin{itemize}

\item Multiple-zeta orbitals are generated with a new algorithm with
  better convergence properties.
\item The generation of polarization orbitals can fall back to a non-perturbative scheme in
  some known problematic cases.
\item Orbitals that would be unbound in the atom are now given a
  default rc (equal to the range of the largest orbital). This value that can be controlled by the option

  \begin{fdfentry}{PAO!rc.unbound.state}[length]<$0.0\,\mathrm{Bohr}$>
    A value of 0.0 will recover the old behavior (stopping if the
    orbital is unbound in the atom).
  \end{fdfentry}

\item The radial grid used in PAO and KB construction, which is
  inherited from that of the pseudopotential tables, is
  re-parametrized by default, to make it finer in the range where most
  relevant cutoffs are located. This is important for
  basis-optimization runs, since there is a more faithful mapping of
  the rc's requested by the optimization algorithm and those actually
  used.
\end{itemize}

In addition, some defaults have been changed to provide a better
overall quality for the automatic basis sets. Note that full
optimization is still preferred for most work:

\begin{itemize}
 \item The default energy-shift has been lowered to 0.01 Ry.
 \item The soft-confinement potential is enabled by default.
 \item The default split-norm parameter for Hydrogen has been increased to 0.45.
 \item A change in the way perturbative polarization orbitals are generated: the
       $l+1$ pseudopotential channel is used, instead of the $l$ channel.
\end{itemize}

\subsubsection{Notes on backward compatibility in regard to new program defaults}

If users want to reuse basis sets generated with previous versions of \siesta, it is
useful to keep in mind the old values of the defaults. In most cases, setting them
back as in the following fdf stanza will recover the old behavior, \textit{except} if
any of the global options were given a different value in the original input. Recall
also that options in the PAO.Basis block take precedence over any global options, but
only if they are explicitly given.

\begin{shellexample}
  PAO.EnergyShift  0.02 Ry
  PAO.SoftDefault    F
  PAO.SplitNormH -1.0
  PAO.OldStylePolOrbs T
  PAO.SplitValence.Legacy T
  ReparametrizePseudos F
  PAO.Polarization.NonPerturbative.Fallback F
  PAO.rc.unbound.state 0.0 Bohr
\end{shellexample}

If users keep the \shell{.ion} or \shell{.ion.nc} files from a
run with a previous version of \siesta, they can be reused
with the \fdf{User.Basis} or \fdf{User.Basis.Netcdf} options. In this
case there is no need to change any flags. This is the most convenient option
to maintain compatibility with older results.
