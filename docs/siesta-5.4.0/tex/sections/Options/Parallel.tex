
\begin{fdfentry}{BlockSize}[integer]<\nonvalue{automatic}>

    The orbitals are distributed over the processors when running in
    parallel using a 1-D block-cyclic algorithm. \fdf{BlockSize} is
    the number of consecutive orbitals which are located on a given
    processor before moving to the next one. Large values of this
    parameter lead to poor load balancing, while small values can lead
    to inefficient execution. The performance of the parallel code can
    be optimised by varying this parameter until a suitable value is
    found.
  
  \end{fdfentry}
  
  \begin{fdfentry}{ProcessorY}[integer]<\nonvalue{automatic}>
  
    The mesh points are divided in the Y and Z directions (more
    precisely, along the second and third lattice vectors) over the
    processors in a 2-D grid. \fdf{ProcessorY} specifies the
    dimension of the processor grid in the Y-direction and must be a
    factor of the total number of processors. Ideally the processors
    should be divided so that the number of mesh points per processor
    along each axis is as similar as possible.
  
    Defaults to a value set automatically by the program. There are two
    methods. The default is to set \fdf{ProcessorY} to a factor of the
    number of processors which takes into account the relative sizes of
    the second and third lattice vectors. An older method based only on
    searching for factors of the number of processors in the set
    \{2,3,5\} can be enabled by the following option.
  
  \end{fdfentry}
  
  \begin{fdflogicalF}{FFT!ProcessorY!Traditional}
    \index{ProcessorY}
  
    If \fdftrue, the program sets the default value for the FFT
    ProcessorY variable by searching for factors of the total number of
    processors in the set \{2,3,5\}. Note that this default value can
    still be overridden by setting \fdf{ProcessorY} explicitly.
  
  \end{fdflogicalF}

  \subsubsection{Parallel decompositions for O(N)}
  \label{parallel-on}
  
  Apart from the default block-cyclic decomposition of the orbital data,
  O(N) calculations can use other schemes which should be more
  efficient: spatial decomposition (based on atom proximity), and domain
  decomposition (based on the most efficient abstract partition of the
  interaction graph of the Hamiltonian).
  
  
  \begin{fdflogicalF}{UseDomainDecomposition}
  
    This option instructs the program to employ a graph-partitioning
    algorithm (using the \program{METIS} library (See
    \url{www.cs.umn.edu/~metis}) to find an efficient distribution of
    the orbital data over processors.  To use this option (meaningful
    only in parallel) the program has to be compiled with the
    preprocessor option \shell{SIESTA\_\_METIS} (or the deprecated
    \shell{ON\_DOMAIN\_DECOMP}) and the \program{METIS} library has to
    be linked in.
  
  \end{fdflogicalF}
  
  \begin{fdflogicalF}{UseSpatialDecomposition}
  
    When performing a parallel order N calculation, this option
    instructs the program to execute a spatial decomposition algorithm
    in which the system is divided into cells, which are then assigned,
    together with the orbitals centered in them, to the different
    processors. The size of the cells is, by default, equal to the
    maximum distance at which there is a non-zero matrix element in the
    Hamiltonian between two orbitals, or the radius of the Localized
    Wannier function - which ever is the larger. If this is the case,
    then an orbital will only interact with other orbitals in the same
    or neighbouring cells. However, by decreasing the cell size and
    searching over more cells it is possible to achieve better load
    balance in some cases. This is controlled by the variable
    \fdf{RcSpatial}.
  
    \note the distribution algorithm is quite fragile and a careful
    tuning of \fdf{RcSpatial} might be needed. This option is therefore
    not enabled by default.
  
  \end{fdflogicalF}
  
  \begin{fdfentry}{RcSpatial}[length]<\nonvalue{maximum orbital range}>
  
    Controls the cell size during the spatial decomposition.
  
  \end{fdfentry}