These are options for the $k$-point grid used in the SCF cycle. For
other specialized grids, see Secs.~\ref{sec:macroscopic-polarization}
and \ref{sec:dos}. The order of the following keywords
is equivalent to their precedence.

\begin{fdfentry}{kgrid!MonkhorstPack}[block/list]<$\Gamma$-point>

  Real-space supercell, whose reciprocal unit cell is that of the
  k-sampling grid, and grid displacement for each grid coordinate.
  Specified as an integer matrix and a real vector:

  \begin{fdfexample}
     %block kgrid.MonkhorstPack
        Mk(1,1)  Mk(2,1)  Mk(3,1)   dk(1)
        Mk(1,2)  Mk(2,2)  Mk(3,2)   dk(2)
        Mk(1,3)  Mk(2,3)  Mk(3,3)   dk(3)
     %endblock
     kgrid.MonkhorstPack [Mk(1,1) Mk(2,2) Mk(3,3)]
  \end{fdfexample}

  where \texttt{Mk(j,i)} are integers and \texttt{dk(i)} are usually
  either 0.0 or 0.5 (the program will warn the user if the displacements
  chosen are not optimal).
  The k-grid supercell is defined from \texttt{Mk}
  as in block \fdf{SuperCell} above, i.e.:
  $KgridSuperCell(ix,i) = \sum_j CELL(ix,j)*Mk(j,i)$.
  Note again that the matrix indexes are inverted: each input line
  gives the decomposition of a supercell vector in terms of the unit
  cell vectors.


  \textit{Use:} Used only if \fdf{SolutionMethod} \fdf*{diagon}.  The
  k-grid supercell is compatible and unrelated (except for the default
  value, see below) with the \fdf{SuperCell} specifier. Both
  supercells are given in terms of the CELL specified by the
  \fdf{LatticeVectors} block.  If \texttt{Mk} is the identity matrix
  and \texttt{dk} is zero, only the $\Gamma$ point of the
  \textbf{unit} cell is used.  Overrides \fdf{kgrid!Cutoff}.

  One may also use the \emph{list} input (last line in above example),
  in that case the block input must not be present and in this case
  the displacement vector cannot be selected.

\end{fdfentry}

\begin{fdfentry}{kgrid!Cutoff}[length]<$0.\,\mathrm{Bohr}$>

  Parameter which determines the fineness of the $k$-grid used for
  Brillouin zone sampling. It is half the length of the smallest
  lattice vector of the supercell required to obtain the same sampling
  precision with a single k point.  Ref: Moreno and Soler, PRB 45,
  13891 (1992).

  \textit{Use:} If it is zero, only the gamma point is used.  The resulting
  k-grid is chosen in an optimal way, according to the method of Moreno
  and Soler (using an effective supercell which is as spherical as
  possible, thus minimizing the number of k-points for a given
  precision). The grid is displaced for even numbers of effective mesh
  divisions.  This parameter is not used if \fdf{kgrid!MonkhorstPack}
  is specified. If the unit cell changes during the calculation (for
  example, in a cell-optimization run, the k-point
  grid will change accordingly (see \fdf{ChangeKgridInMD} for the case
  of variable-cell molecular-dynamics runs, such as Parrinello-Rahman).
  This is analogous to the changes in the
  real-space grid, whose fineness is specified by an energy cutoff. If
  sudden changes in the number of k-points are not desired, then the
  Monkhorst-Pack data block should be used instead. In this case there
  will be an implicit change in the quality of the sampling as the cell
  changes. Both methods should be equivalent for a well-converged
  sampling.

\end{fdfentry}

\begin{fdfentry}{kgrid!File}[string]<none>

  Specify a file from where the $k$-points are read in.  The format of
  the file is identical to the \sysfile{KP} file with the exception
  that the $k$-points are given in units of the reciprocal lattice
  vectors. I.e. in the range of $]-1/2 ; 1/2]$.

  An example input may be (not physically justified in any sense):
  \begin{shellexample}
    4
    1 0.0 0.0 0.0 0.25
    2 0.5 0.5 0.5 0.25
    3 0.2 0.2 0.2 0.25
    4 0.3 0.3 0.3 0.25
  \end{shellexample}
  The first integer specifies the total number of $k$-points in the
  file. The first column is an index; the next 3 columns are the
  $k$-point specification for each of the reciprocal lattice vectors
  while the fifth column is the weight for the $k$-point.

  \siesta\ checks whether the sum of weights equals 1. If not,
  \siesta\ will die.

\end{fdfentry}

\begin{fdflogicalT}{ChangeKgridInMD}

  If \fdftrue, the $k$-point grid is recomputed at every
  iteration during MD runs that potentially change the unit cell:
  Parrinello-Rahman, Nose-Parrinello-Rahman, and Anneal. Regardless of
  the setting of this flag, the k-point grid is always updated at
  every iteration of a variable-cell optimization and after each step
  in a ``siesta-as-server'' run.

  The only reason to set it to \fdffalse\ would be to avoid sudden
  jumps in some properties when the sampling changes; but if the
  calculation is well-converged there should be no problems when
  the update is enabled.

\end{fdflogicalT}


\begin{fdflogicalT}{TimeReversalSymmetryForKpoints}
  \fdfdepend{Spin,Spin!Spiral}

If \fdftrue, the k-points in the BZ generated by the methods above
are paired as ($k$, $-k$) and only one member of the pair is retained. This
symmetry is valid in the absence of external magnetic fields or
non-colinear/spin-orbit interaction.

This flag is only honored for spinless or collinear-spin calculations,
as the code will produce wrong results if there is no support for the
appropriate symmetrization.

The default value is \fdftrue\ unless: a) the option \fdf{Spin!Spiral}
is used. In this case time-reversal-symmetry is broken explicitly. b)
non-colinear/spin-orbit calculations. This case is less clear cut, but
the time-reversal symmetry is not used to avoid possible breakings due
to subtle implementation details, and to make the set of wavefunctions
compatible with spin-orbit case in analysis tools.


\end{fdflogicalT}

\subsubsection{Output of k-point information}
\index{output!grid $\vec k$ points}

The coordinates of the $\vec k$ points used in the sampling
are always stored in the file \sysfile{KP}.

\begin{fdflogicalF}{WriteKpoints}
  \index{output!grid $\vec k$ points}

  If \fdftrue\ it writes the coordinates of the $\vec k$ vectors used
  in the grid for $k$-sampling, into the main output file.

  Default depends on \fdf{LongOutput}.

\end{fdflogicalF}
