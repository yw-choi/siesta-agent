 \siesta\ is ready to work as a QM-engine for hybrid Quantum Mechanics/
 Molecular Mechanics (QM/MM) simulations, using an external molecular
 mechanics software as a driver.
 For this purpose, you should run \siesta\ independently, since communication
 is done via either pipes or sockets; which is to say, you must have both your
 MM code and \siesta\ running simultaneously. You will need all of the
 regular components of a \siesta\ calculation, but atomic positions for the
 QM region (and cell dimensions) will be overwritten with data coming from
 the MM driver.

 \textbf{NOTE:} Please refer to the developer documentation on how to
 implement the communication from the MM side, and check the qmmm\_extern
 test for a reference implementation.

 It is also possible to run a stand-alone calculation using only \siesta\,
 providing a set of point charges and their coordinates in the fdf files.
 After calculation, \siesta\ will output the forces on the point charges in
 a .FAPC file. The following options refer to both the stand-alone
 calculations and when \siesta\ isused as a QM engine for an external driver
 program.

 \begin{fdflogicalF}{QMMM.Enabled}
  Enables the application of an external potential created by point charges
  near the QM system; i.e., enables QM/MM calculations.

 \end{fdflogicalF}

 \begin{fdfentry}{QMMM.CoulombType}[integer]<1>
  When set to 1 (default), uses Ewald summations for the electrostatic
  interaction between QM and MM regions.
  Setting this variable to 2 switches this scheme to just real space
  distance cut-off. This is not recommended, and the option is kept only
  for testing purposes.
 \end{fdfentry}

 \begin{fdfentry}{QMMM.CutOff}[length]<$20\,\mathrm{Bohr}$>
  Cut-off distance for QM-MM interactions. This magnitude is only relevant
  in the real part of the Ewald summation, or in the entire cutoff scheme.
  It is highly advisable that this magnitude does not go above one half
  of the simulation box's shortest side.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.DensityCut}[length]<$1.10^{-6}\,\mathrm{Bohr}$>
  Tolerance when deciding if a given grid point is too close to a
  classical point charge. This is usually not worth changing.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.Ewald.Rcut}[length]<$20\,\mathrm{Bohr}$>
  In Ewald summations, this value is used as a cut-off distance for
  how long the direct summation goes. Same considerations as with
  QMMM.CutOff apply here, and it is usually a good idea to keep of
  them in similar magnitudes if not the same.

  This radius is also used to set the value of the Ewald alpha coefficient,
  and the reciprocal space summation cut-off.

 \end{fdfentry}

 \begin{fdfentry}{PartialCharges}[block]

  This block contains the positions (in Angstrom) and charge values (in e-)
  for classical point charges. Each line corresponds to a given charge,
  indicating first x, y and z coordinates, and then the charge value.

  \begin{shellexample}
       from iq = 1 to ncharges
            read: x(iq), y(iq), z(iq), q(iq)
  \end{shellexample}

  It is important to note that this block will be ignored if \siesta\ is
  used by an external MM driver.
 \end{fdfentry}

 The following options are experimental and enable some form of
 smoothing potential along the Z-axis when dealing with electrodes.
 Use these only if you know exactly what you're doing.

 \begin{fdflogicalF}{QMMM.SmoothElectrode}
  Enables potential smoothing.

 \end{fdflogicalF}

 \begin{fdfentry}{QMMM.SmoothElectrode.Electrode}[length]<$0\,\mathrm{Bohr}$>
  Length of the electrodes.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.SmoothElectrode.Smooth}[length]<$0\,\mathrm{Bohr}$>
  Length of the smoothing section.

 \end{fdfentry}

 \subsection{Using external MM driver}
 The following options are only used if \siesta\ is intended to run
 with an external MM driver. Most of these require knowing at least
 a bit of how the communication is handled by the MM program.

 \begin{fdfentry}{QMMM.Driver}[string]<$unknown$>
  Indicates to \siesta\ the name of the MM driver used. This
  option has currently no effect on any part of the run, but
  may be used in the future.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.Driver.Type}[string]<$socket$>
  The type of communication used by the MM program, can be
  either "socket" or "pipe".

 \end{fdfentry}

 If the chosen communication type is "pipe", the following
 three options are also relevant:

 \begin{fdfentry}{QMMM.Driver.QMRegionFile}[string]<$siesta.qmatoms$>
  The name of the pipe/file containing the incoming QM coordinates
  and cell dimensions.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.Driver.MMChargeFile}[string]<$siesta.mmatoms$>
  The name of the pipe/file containing the incoming MM coordinates
  and their charge values.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.Driver.ForceOutFile}[string]<$siesta.allforces$>
  The name of the pipe/file containing the outgoing energy, forces and
  stress so that they are read by the MM program.

 \end{fdfentry}

 Otherwise, if the chosen communication type is "socket", the following
 three options are relevant instead:

 \begin{fdfentry}{QMMM.Driver.Address}[string]<$localhost$>
  The address of the socket used for communication. See also SocketType
  below in case the address is an IP address.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.Driver.Port}[integer]<$10002$>
  For sockets that go over IP, the number of the port used for communications.

 \end{fdfentry}

 \begin{fdfentry}{QMMM.Driver.SocketType}[string]<$inet$>
  Can be either "inet" (for TCP/IP sockets) or "unix" for local sockets.

 \end{fdfentry}


 \subsection{The in-house QM/MM driver}
 \subsubsection{Running the driver}
 \siesta\ comes with a simple Molecular Mechanics program to use as the
 main driver for QM/MM simulations. As an additional input for this program,
 one needs to provide an extra "amber.parm" parameter file which contains
 all of the AMBER forcefield parameters needed for the classical part. There
 are a few examples provided in /Util/QMMM-driver/Tests.

 This driver can be used in two ways to communicate with siesta:
\begin{itemize}
  \item Launching both the driver and \siesta\ as different processes:

  \begin{shellexample}
    siesta_qmmm < driver_input.fdf > driver_out.out &
    siesta_qmmm < siesta_input.fdf > siesta_out.out
  \end{shellexample}

  Note that two separate input files are needed, one for the driver and
  one for \siesta\ .

  \item Launching \siesta\ as a subprocess from the driver, using
  the \fdf{LaunchSiesta} option. In this case, a separate \siesta\ input
  file is not needed, and the driver will pass along the options present
  in its own fdf file.
\end{itemize}

  Communications are done via pipes (see previous section), and if \siesta\
  is launched independently (first option above), the following block is
  necessary on the \siesta\ input file:

  \begin{shellexample}
    QMMM.Driver.QMRegionFile {label}.siesta.coords
    QMMM.Driver.MMChargeFile {label}.siesta.pc
    QMMM.Driver.ForceOutFile {label}.siesta.forces
  \end{shellexample}

  Replace \{label\} for the system label you are using in the QMMM driver.


  \subsubsection{The MM parameter file}
  By default, the MM parameter file is taken as an "amber.parm" file residing in
  the working directory. There are two different ways to specify a different
  path or filename:

  \begin{itemize}
    \item Via the SIESTA\_MM\_PARM\_FILE environment variable. It should point
          to the specific file. ( for example:
          SIESTA\_MM\_PARM\_FILE=/home/myparm.parm )

    \item Via the \fdf{MM.ParmFile} option within the driver's fdf file.
  \end{itemize}

  \subsubsection{QM/MM driver-specific options}
  The driver inherits from \siesta\ most of the options related to system
  description and molecular dynamics, thus variables such as \fdf{NumberOfAtoms}
  will remain the same.

  However, there are a few driver-specific options.

  \begin{fdfentry}{QM.AtomTypes}[block]
    This block contains the MM identities for atoms in the QM region. This
    is only relevant for Lennard-Jones interactions. Atoms must be in the
    same order as in the \fdf{AtomicCoordinatesAndAtomicSpecies} block. For
    example, for a single water molecule in the QM region:

    \begin{shellexample}
      %block QM.AtomTypes
        OW
        HW
        HW
      %endblock QM.AtomTypes
    \end{shellexample}

    The atom types (OW, HW) must coincide with the information available in the
    amber.parm file.

  \end{fdfentry}

  \begin{fdfentry}{MM.ParmFile}[string]<$'amber.parm'$>
    File containing the classical (MM) forcefield parameters.
  \end{fdfentry}

  \begin{fdfentry}{NumberOfMMAtoms}[integer]<$0$>
    The number of classical MM atoms in the system (not counting link atoms).
  \end{fdfentry}

  \begin{fdfentry}{MM.Atoms}[block]
    This block contains names and coordinates for MM atoms. It follows a
    structure similar to that of a PDB file, thus making it easier to copy
    from an available PDB:

    \begin{shellexample}
      %block MM.Atoms
        ATOM      1  O   HOH     1     11.610  15.591  10.441
        ATOM      2  H1  HOH     1     10.681  15.570  10.811
        ATOM      3  H2  HOH     1     11.621  15.201   9.521
        ATOM      4  O   HOH     2     11.560  12.061   0.651
        ATOM      5  H1  HOH     2     11.911  11.890   1.571
        ATOM      6  H2  HOH     2     10.681  11.610   0.530
      %endblock MM.Atoms
    \end{shellexample}

    It begins with a single word, followed by the atom index, then the
    atom name, then the residue name and the residue index, and finally the X,
    Y, and Z coordinates. Both indices start from 1. \textbf{Residue and atom
    names must coincide with the information present in the amber.parm file}.

  \end{fdfentry}

  \begin{fdfentry}{CoulombType}[string]<$'ewald'$>
    Sets the type of description for coulomb interactions in MM-MM and QM-MM
    interactions. Can be either "ewald" or "cut-off".
  \end{fdfentry}

  \begin{fdfentry}{MM.Cutoff}[length]<$0.8,\mathrm{Ang}$>
    For MM-MM interactions. When Ewald summations are used, this will also be
    the value for \fdf{QMMM.Ewald.Rcut}.
  \end{fdfentry}

  \begin{fdfentry}{Block.Cutoff}[length]<$100.0,\mathrm{Ang}$>
    If given a value of 99.0 Ang or below, MM atoms that are further than a
    \fdf{Block.Cutoff} distance from the QM region will be frozen and prevented from
    moving during the molecular dynamics.
  \end{fdfentry}

  \begin{fdflogicalF}{CenterQMSystem}
    At every MD step, re-center the entire system on the geometrical center for
    the QM region.
  \end{fdflogicalF}

  \begin{fdflogicalF}{LaunchSiesta}
    Launch \siesta\ as a subprocess for the QMMM driver. This avoids the need
    to run separate processes. By default, the driver will look for a \siesta\
    excecutable in the working directory, but a different location can be
    provided using the SIESTA environment variable. For example:

    \begin{shellexample}
      SIESTA=path/to/siesta/bin  \
        siesta_qmmm < driver_input.fdf > driver_out.out
    \end{shellexample}

    SIESTA\_PARALLEL\_COMMAND can be combined with the SIESTA environment variable,
    see \fdf{MPICommand}.
  \end{fdflogicalF}

  \begin{fdfentry}{NumberMPInodes}[integer]<$1$>
    When using \fdf{LaunchSiesta}, this option can be used to choose the amount
    of CPUs used for \siesta\ itself (the driver always runs in serial). When
    set to 1, \fdf{MPICommand} will be ignored.

    This option can be overridden with the SIESTA\_PARALLEL\_COMMAND environment
    variable (see \fdf{MPICommand}).
  \end{fdfentry}

  \begin{fdfentry}{MPICommand}[string]<$'mpirun'$>
    When using \fdf{LaunchSiesta}, this option can be used to choose a different
    program for parallelization, for example 'srun'.

    This can be overridden with the SIESTA\_PARALLEL\_COMMAND environment
    variable. In that case, SIESTA\_PARALLEL\_COMMAND must contain all of the
    information needed for the MPI launcher (e.g., the number of CPUs). This
    can be used as follows:

    \begin{shellexample}
      SIESTA_PARALLEL_COMMAND="srun -n 8" \
        siesta_qmmm < driver_input.fdf > driver_out.out
    \end{shellexample}

    SIESTA\_PARALLEL\_COMMAND can be combined with the SIESTA environment variable,
    see \fdf{LaunchSiesta}.
  \end{fdfentry}